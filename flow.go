package conntrack

import (
	"fmt"

	"github.com/mdlayher/netlink"

	"github.com/ti-mo/netfilter"
)

// Flow represents a snapshot of a Conntrack connection.
type Flow struct {
	ID        Num32
	Timeout   Num32
	Timestamp Timestamp

	Status    Status
	ProtoInfo ProtoInfo
	Helper    Helper

	Zone Num16

	CountersOrig, CountersReply Counter

	SecurityContext Security

	TupleOrig, TupleReply, TupleMaster Tuple

	SeqAdjOrig, SeqAdjReply SequenceAdjust

	Labels, LabelsMask Bitfield

	Mark, MarkMask, Use Num32
}

// UnmarshalAttributes calls unmarshal operations on a list of netfilter.Attributes.
func (f *Flow) UnmarshalAttributes(attrs []netfilter.Attribute) error {

	for _, attr := range attrs {

		switch at := AttributeType(attr.Type); at {

		// CTA_TIMEOUT is the time until the Conntrack entry is automatically destroyed.
		case CTATimeout:
			if err := f.Timeout.UnmarshalAttribute(attr); err != nil {
				return err
			}
		// CTA_ID is the tuple hash value generated by the kernel. It can be relied on for flow identification.
		case CTAID:
			if err := f.ID.UnmarshalAttribute(attr); err != nil {
				return err
			}
		// CTA_USE is the flow's kernel-internal refcount.
		case CTAUse:
			if err := f.Use.UnmarshalAttribute(attr); err != nil {
				return err
			}
		// CTA_MARK is the connection's connmark
		case CTAMark:
			if err := f.Mark.UnmarshalAttribute(attr); err != nil {
				return err
			}
		// CTA_MARK_MASK is never sent by the kernel, but can be used for kernel-space dump filtering!
		case CTAMarkMask:
			if err := f.MarkMask.UnmarshalAttribute(attr); err != nil {
				return err
			}
		// CTA_ZONE describes the Conntrack zone the flow is placed in. This can be combined with a CTA_TUPLE_ZONE
		// to specify which zone an event originates from.
		case CTAZone:
			if err := f.Zone.UnmarshalAttribute(attr); err != nil {
				return err
			}
		// CTA_LABELS is a binary bitfield attached to a connection that is sent in
		// events when changed, as well as in response to dump queries.
		case CTALabels:
			f.Labels.UnmarshalAttribute(attr) // Does not error
		// CTA_LABELS_MASK is never sent by the kernel, but it can be used
		// in set / update queries to mask label operations on the kernel state table.
		// it needs to be exactly as wide as the CTA_LABELS field it intends to mask.
		case CTALabelsMask:
			f.LabelsMask.UnmarshalAttribute(attr) // Does not error
		// CTA_TUPLE_* attributes are nested and contain source and destination values for:
		// - the IPv4/IPv6 addresses involved
		// - ports used in the connection
		// - (optional) the Conntrack Zone of the originating/replying side of the flow
		case CTATupleOrig:
			if err := f.TupleOrig.UnmarshalAttribute(attr); err != nil {
				return err
			}
		case CTATupleReply:
			if err := f.TupleReply.UnmarshalAttribute(attr); err != nil {
				return err
			}
		case CTATupleMaster:
			if err := f.TupleMaster.UnmarshalAttribute(attr); err != nil {
				return err
			}
		// CTA_STATUS is a bitfield of the state of the connection
		// (eg. if packets are seen in both directions, etc.)
		case CTAStatus:
			if err := f.Status.UnmarshalAttribute(attr); err != nil {
				return err
			}
		// CTA_PROTOINFO is sent for TCP, DCCP and SCTP protocols only. It conveys extra metadata
		// about the state flags seen on the wire. Update events are sent when these change.
		case CTAProtoInfo:
			if err := f.ProtoInfo.UnmarshalAttribute(attr); err != nil {
				return err
			}
		case CTAHelp:
			if err := f.Helper.UnmarshalAttribute(attr); err != nil {
				return err
			}
		// CTA_COUNTERS_* attributes are nested and contain byte and packet counters for flows in either direction.
		case CTACountersOrig:
			if err := f.CountersOrig.UnmarshalAttribute(attr); err != nil {
				return err
			}
		case CTACountersReply:
			if err := f.CountersReply.UnmarshalAttribute(attr); err != nil {
				return err
			}
		// CTA_SECCTX is the SELinux security context of a Conntrack entry.
		case CTASecCtx:
			if err := f.SecurityContext.UnmarshalAttribute(attr); err != nil {
				return err
			}
		// CTA_TIMESTAMP is a nested attribute that describes the start and end timestamp of a flow.
		// It is sent by the kernel with dumps and DESTROY events.
		case CTATimestamp:
			if err := f.Timestamp.UnmarshalAttribute(attr); err != nil {
				return err
			}
		// CTA_SEQADJ_* is generalized TCP window adjustment metadata. It is not (yet) emitted in Conntrack events.
		// The reason for its introduction is outlined in https://lwn.net/Articles/563151.
		// Patch set is at http://www.spinics.net/lists/netdev/msg245785.html.
		case CTASeqAdjOrig:
			if err := f.SeqAdjOrig.UnmarshalAttribute(attr); err != nil {
				return err
			}
		case CTASeqAdjReply:
			if err := f.SeqAdjReply.UnmarshalAttribute(attr); err != nil {
				return err
			}
		// TODO: Implement CTASynProxy
		case CTASynProxy:
			return errNotImplemented
		default:
			return fmt.Errorf(errAttributeUnknown, at)
		}
	}

	return nil
}

// FlowsFromNetlink unmarshals a list of flows from a list of Netlink messages.
// This method can be used to parse the result of a dump or get query.
func FlowsFromNetlink(nlm []netlink.Message) ([]Flow, error) {

	// Pre-allocate to avoid extending output slice on every op
	out := make([]Flow, len(nlm))

	for i := 0; i < len(nlm); i++ {

		attrs, err := netfilter.AttributesFromNetlink(nlm[i])
		if err != nil {
			return nil, err
		}

		var f Flow
		err = f.UnmarshalAttributes(attrs)
		if err != nil {
			return nil, err
		}

		out[i] = f
	}

	return out, nil
}
